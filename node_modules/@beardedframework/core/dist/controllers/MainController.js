"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResponseService_1 = require("../services/ResponseService");
const lumberjack_1 = require("@beardedframework/lumberjack");
class MainController {
    constructor() {
        /*
         * @var { ResponseService } response service
         */
        this.response = ResponseService_1.default;
        /*
         * crud method to fetch data
         *
         * @param { model } model
         * @param { express.req } req
         *
         * @rerurn { promise }
         * -*/
        this.storeCrud = (Model, req) => __awaiter(this, void 0, void 0, function* () {
            const self = this;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const body = req.body;
                const elToBeSaved = self.createObject(Model, body);
                const model = Model.create(elToBeSaved);
                let err, created;
                [err, created] = yield lumberjack_1.to(model.save());
                if (err || !created)
                    reject(err);
                let el = Model.find(created.insertId);
                resolve(el);
            }));
        });
        /*
         * crud method to fetch data
         *
         * @param { model } model
         * @param { express.req } req
         *
         * @rerurn { promise }
         * -*/
        this.updateCrud = (Model, req) => __awaiter(this, void 0, void 0, function* () {
            const self = this;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const id = req.params.id;
                const body = req.body;
                const elToBeSaved = self.createObject(Model, body);
                let error, model;
                [error, model] = yield lumberjack_1.to(Model.find(id));
                if (error || !model)
                    reject(error);
                model = this.updateModelValues(model, elToBeSaved);
                let err, updated;
                [err, updated] = yield lumberjack_1.to(model.save());
                if (err || !updated)
                    reject(err);
                resolve(model);
            }));
        });
    }
    /*
     * crud method to fetch data
     *
     * @param { model } model
     * @param { number } page
     * @param { boolean } isComplex
     *
     * @rerurn { promise }
     * -*/
    fetchCrud(model, page, isComplex = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isComplex)
                console.log('there is no complex query yet');
            else {
                if (page > 0)
                    return model.fetchPaginated(page);
                return model.fetchAll();
            }
        });
    }
    /*
     * crud method to get single data
     *
     * @param { model } model
     * @param { number } id
     * @param { boolean } isComplex
     *
     * @rerurn { promise }
     * -*/
    getCrud(model, id, isComplex = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isComplex)
                console.log('there is no complex query yet');
            else {
                return model.find(id);
            }
        });
    }
    /*
     *
     * generate the element to be saved by given model
     *
     * @param { model } model
     * @param { object } body
     *
     * @return object
     *
     * */
    createObject(Model, body) {
        let model = new Model();
        let elToBeSaved = {};
        for (let key in body) {
            if (model.fillable.includes(key))
                elToBeSaved[key] = body[key];
        }
        return elToBeSaved;
    }
    /*
     *
     * sync model data and values to be saved
     *
     * @param { model } model
     * @param { object } body
     *
     * @return object
     *
     * */
    updateModelValues(model, values) {
        for (let key in values) {
            model.data[key] = values[key];
        }
        return model;
    }
}
exports.default = MainController;
//# sourceMappingURL=MainController.js.map