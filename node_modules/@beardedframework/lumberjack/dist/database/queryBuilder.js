"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const selector_1 = require("./selector");
/*
 * @class queryBuilder
 */
class queryBuilder {
    /*
     * class construtor
     * */
    constructor(tableName = null) {
        this.query = {
            select: '',
            ifSelect: '',
            table: '',
            where: '',
            whereIn: '',
            whereBetween: '',
            join: '',
            leftJoin: '',
            rightJoin: '',
            outerJoin: '',
            caseSelect: '',
            groupBy: '',
            orderBy: '',
            limit: '',
            model: ''
        };
        this.queryCaseWhens = '';
        this.paginator = {
            limit: 15,
            query: '',
            total: 0,
            links: 2
        };
        if (tableName !== null)
            this.query.table = tableName;
        this.selector = new selector_1.default();
    }
    /*
     * start a new queryBuilder selecting
     * @param { Array } args
     * @return { queryBuilder }  instance
     * */
    select(...args) {
        this.query.select = `SELECT ${args.toString()} `;
        //console.log(this.query);
        //Logger.info(this.query);
        // Logger.info('select need to be implemented');
        //
        return this;
    }
    /*
     * add where to builder
     * @param { String } field
     * @param { String }  operator
     * @param { any } value
     * @param { model } model
     * @return { queryBuilder } instance
     * */
    where(field, operator, value, model = null) {
        return this.whereCompleter(field, operator, value);
    }
    /*
     * add where IN to builder
     * @param { String } field
     * @param { Array } values
     * @return { queryBuilder } instance
     * */
    whereIn(field, values) {
        this.query.whereIn += ` WHERE ${field} IN (${values.toString()})`;
        return this;
    }
    /*
     * add between to builder
     * @param { String } field
     * @param { String } firstValue
     * @param { String } secondValue
     * @return { queryBuilder } instance
     * */
    whereBetween(field, firstValue, secondValue) {
        this.query.whereBetween += ` WHERE ${field} BETWEEN  ${firstValue} AND ${secondValue} `;
        return this;
    }
    /*
     * add orWhere to builder
     * @param { String } field
     * @param { String } operator
     * @param { any } value
     * @return { queryBuilder } instance
     * */
    orWhere(field, operator, value) {
        return this.whereCompleter(field, operator, value, 'OR');
    }
    /*
     * generate case selects
     * @param { String } indentifier
     * @param { Function } func
     * @return { queryBuilder } instance
     * */
    caseSelect(identifier, callable) {
        callable(this);
        this.query.caseSelect += `, CASE ${this.queryCaseWhens}  END as "${identifier}"`;
        this.queryCaseWhens = '';
        return this;
    }
    /*
     * query if to the builder
     * @param { String } identifier
     * @param { String } condition
     * @param { String } valueIfTrue
     * @param { String } valueIfFalse
     * @return { queryBuilder } instance
     * */
    ifSelect(identifier, condition, valueIfTrue, valueIfFalse) {
        let queryIf = `, if(${condition}, "${valueIfTrue}", "${valueIfFalse}") as ${identifier}`;
        this.query.ifSelect += queryIf;
        return this;
    }
    /*
     * add when to case select builder
     * @param { String } firstArgument
     * @param { String } operator
     * @param { String } secondArgument
     * @param { String } then
     * @return { queryBuilder } instance
     * */
    when(firstArgument, operator, secondArgument, then) {
        this.queryCaseWhens += ` WHEN ${firstArgument} ${operator} ${secondArgument}  THEN "${then}" `;
        return this;
    }
    /*
     * add join to builder
     * @param { String } secondTable
     * @param { String } firstTableColumnName
     * @param { String } operator
     * @param { any } secondTableColumnName
     * @return { queryBuilder } instance
     * */
    join(secondTable, firstTableColumnName, operator, secondTableColumnName) {
        this.query.join += ` INNER JOIN ${secondTable} ON  ${firstTableColumnName} ${operator}  ${secondTableColumnName} `;
        return this;
    }
    /*
     * add outerJoin to builder
     * @param { String } secondTable
     * @param { String } firstTableColumnName
     * @param { String } operator
     * @param { any } secondTableColumnName
     * @return { queryBuilder } instance
     * */
    outerJoin(secondTable, firstTableColumnName, operator, secondTableColumnName) {
        this.query.outerJoin += ` FULL OUTER JOIN ${secondTable} ON  ${firstTableColumnName} ${operator}  ${secondTableColumnName} `;
        return this;
    }
    /*
     * add rightJoin to builder
     * @param { String } secondTable
     * @param { String } firstTableColumnName
     * @param { String } operator
     * @param { any } secondTableColumnName
     * @return { queryBuilder } instance
     * */
    rightJoin(secondTable, firstTableColumnName, operator, secondTableColumnName) {
        this.query.rightJoin += ` RIGHT JOIN ${secondTable} ON  ${firstTableColumnName} ${operator}  ${secondTableColumnName} `;
        return this;
    }
    /*
     * add leftJoin to builder
     * @param { String } secondTable
     * @param { String } firstTableColumnName
     * @param { String } operator
     * @param { any } secondTableColumnName
     * @return { queryBuilder } instance
     * */
    leftJoin(secondTable, firstTableColumnName, operator, secondTableColumnName) {
        this.query.leftJoin += ` LEFT JOIN ${secondTable} ON  ${firstTableColumnName} ${operator}  ${secondTableColumnName} `;
        return this;
    }
    /*
     * add order by to builder
     * @param { String } order
     * @return { queryBuilder } instance
     * */
    orderBy(order) {
        this.query.orderBy = ` ORDER BY ${order} `;
        return this;
    }
    /*
     * add group by to builder
     * @param { String } field
     * @return { queryBuilder } instance
     * */
    groupBy(field) {
        this.query.groupBy = ` GROUP BY ${field} `;
        return this;
    }
    /*
     * return the query
     * @return { collection }
     * */
    get() {
        let query = this.buildQryString();
        return this.selector.statement(query, this.query.model);
    }
    /*
     * return the first element of query
     * @return { model }
     * */
    first() {
        this.query.limit = ' LIMIT 1';
        return this.get();
    }
    /*
     * add limit to the query
     * @param { number } size
     * @return { queryBuilder } instance
     * */
    limit(size) {
        this.query.limit = `LIMIT ${size} `;
        return this;
    }
    /*
     * build the query string
     * @return { Promise }
     * */
    paginate(page, limit = null, links = null) {
        return __awaiter(this, void 0, void 0, function* () {
            var self = this;
            if (limit !== null)
                self.paginator.limit = limit;
            if (links !== null)
                self.paginator.links = links;
            return new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    self.paginator.page = page;
                    let qry = self.buildQryString();
                    let qryToGetTotal = "SELECT COUNT(*) as count FROM (" + qry.slice(0, -1) + ") as TMP";
                    const resp = yield self.selector.freeStatement(qryToGetTotal);
                    if (resp.length > 0)
                        self.paginator.total = resp[0].count;
                    else
                        self.paginator.total = 1;
                    let offset = (self.paginator.page - 1) * self.paginator.limit;
                    if (self.selector.dbEngine == 'mysql' || self.selector.dbEngine == 'postgres')
                        self.query.limit = ` LIMIT ${self.paginator.limit} OFFSET ${offset} `;
                    self.paginator.query = self.buildQryString();
                    let response = yield self.selector.statement(self.paginator.query, self.query.model);
                    const respFinal = {
                        paginator: self.linkGenerator(),
                        data: response.toJson()
                    };
                    resolve(respFinal);
                });
            });
        });
    }
    /*
     * build the query string
     * @return { String }
     * */
    buildQryString() {
        let qryObj = this.query;
        let query = ` ${qryObj.select} ${qryObj.caseSelect} ${qryObj.ifSelect} ${qryObj.table} ${qryObj.join} ${qryObj.leftJoin} ${qryObj.rightJoin} ${qryObj.outerJoin} ${qryObj.where} ${qryObj.whereIn} ${qryObj.whereBetween} ${qryObj.groupBy} ${qryObj.orderBy} ${qryObj.limit};`;
        //Logger.info(query);
        //console.log(query);
        return query;
    }
    /*
     *
     * set the model to the builder
     * @param { model/model } model
     * @return { void }
     * */
    setModel(model) {
        const instance = new model();
        this.query.model = model;
        this.query.table = ` FROM ${instance.table} `;
    }
    /*
     * generate the links of the paginator
     * @return { Object }
     * */
    linkGenerator() {
        let self = this;
        let last = Math.ceil(self.paginator.total / self.paginator.limit);
        let page = parseInt(self.paginator.page);
        let linksPaginator = {
            lastPage: last,
            firstPage: 1,
            currentPage: self.paginator.page,
            currentLink: '?page=' + self.paginator.page,
            firstPaginated: ((self.paginator.page - self.paginator.links) > 0) ? self.paginator.page - self.paginator.links : 1,
            endPaginated: ((self.paginator.page + self.paginator.links) < last) ? self.paginator.page + self.paginator.links : last,
            firstLink: '',
            perPage: self.paginator.limit,
            middleLinks: [],
            entries: self.paginator.total,
            nextPage: null,
            nextLink: '',
            previousPage: null,
            previousLink: '',
            lastLink: '',
        };
        if (linksPaginator.firstPaginated > 1) {
            linksPaginator.firstLink = '?page=1';
        }
        for (let i = linksPaginator.firstPaginated; i <= linksPaginator.endPaginated; i++) {
            linksPaginator.middleLinks.push(`?page=${i}`);
        }
        if (linksPaginator.endPaginated < linksPaginator.lastPage) {
            linksPaginator.lastLink = `?page=${linksPaginator.lastPage}`;
        }
        if (linksPaginator.currentPage < linksPaginator.endPaginated) {
            linksPaginator.nextPage = parseInt(linksPaginator.currentPage) + 1;
            linksPaginator.nextLink = `?page=${linksPaginator.nextPage}`;
        }
        if (linksPaginator.currentPage > linksPaginator.firstPaginated) {
            linksPaginator.previousPage = parseInt(linksPaginator.currentPage) - 1;
            linksPaginator.previousLink = `?page=${linksPaginator.previousPage}`;
        }
        return linksPaginator;
    }
    /*
     * add where to builder
     * @param { String } field
     * @param { String } operator
     * @param { any } value
     * @param { string } concater
     * @return { queryBuilder } instance
     * */
    whereCompleter(field, operator, value, concater = 'AND') {
        let where = ` ${field} ${operator} '${value}'`;
        if (this.query.where == '')
            this.query.where += ` WHERE ${where}`;
        else
            this.query.where += ` ${concater} ${where}`;
        return this;
    }
    /*
     * add where to builder
     * @param { models/model } model
     * @return { Promise }
     * */
    static fetchAllrows(model) {
        return __awaiter(this, void 0, void 0, function* () {
            //let selectorInstance = new selector();
            //
            return model.select('*').get();
            //return selectorInstance.statement(`select * from ${modelInstance.table} `, model);
        });
    }
    static fetchAllpaginated(model, page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            //let selectorInstance = new selector();
            //console.log(model);
            return model.select('*').paginate(page);
        });
    }
    /*
     * find row by id
     * @param { number } id
     * @param { models/model } model
     * @return { Promise }
     * */
    static findRow(id, model) {
        return __awaiter(this, void 0, void 0, function* () {
            let selectorInstance = new selector_1.default();
            let modelInstance = new model();
            let fields = modelInstance.fillable.toString();
            return selectorInstance.statement(`select * from ${modelInstance.table} where id=${id}`, model);
        });
    }
}
exports.default = queryBuilder;
//# sourceMappingURL=queryBuilder.js.map