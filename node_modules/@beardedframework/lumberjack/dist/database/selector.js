"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const CollectionService_1 = require("../services/CollectionService");
const to_1 = require("../services/to");
class selector {
    /*
     * class constructor
     *
     * */
    constructor() {
        /*
         * @var { array }
         */
        this.noUpdateAblesWithData = ['id', 'created_at', 'updated_at'];
        this._dbEngine = process.env.DB_CONNECTION;
        this.db = config_1.default.Instance.db;
    }
    /*
     * db getter
     **/
    get dbEngine() {
        return this._dbEngine;
    }
    /*
     * db setter
     **/
    set dbEngine(value) {
        this._dbEngine = value;
    }
    /*
     * create a new entry of model on database
     *
     * @param { mode/Model } modelInstance
     *
     * @return { Promise }
     * */
    save(modelInstance) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = modelInstance.data;
            let keys = '';
            let values = '';
            for (let key in data) {
                if (!key || !data[key])
                    continue;
                keys += `${key}, `;
                values += `'${data[key]}', `;
            }
            let timestamp;
            if (this.dbEngine == 'mysql')
                timestamp = 'CURRENT_TIMESTAMP()';
            else
                timestamp = 'CURRENT_TIMESTAMP';
            const query = `INSERT INTO  ${modelInstance.table} (${keys} created_at, updated_at) VALUES (${values} ${timestamp}, ${timestamp})`;
            //return this.selector.statement('select count(id) from users');
            return this.saveOrUpdate(query);
        });
    }
    /*
     * update the model data
     *
     * @param { mode/Model } modelInstance
     *
     * @return { Promise }
     *
     * */
    update(modelInstance) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = modelInstance.data;
            let toUpdate = '';
            for (let key in data) {
                if (!key || !data[key] || this.noUpdateAblesWithData.includes(key))
                    continue;
                toUpdate += `${key} = '${data[key]}', `;
            }
            let timestamp;
            if (this.dbEngine == 'mysql')
                timestamp = 'CURRENT_TIMESTAMP()';
            else
                timestamp = 'CURRENT_TIMESTAMP';
            let query = `UPDATE  ${modelInstance.table} SET ${toUpdate} updated_at=${timestamp} where id='${data.id}'`;
            console.log(query);
            let err, response;
            [err, response] = yield to_1.default(this.saveOrUpdate(query));
            if (!response || err)
                return err;
            if (response.changedRows < 1)
                return 'error';
            return modelInstance;
        });
    }
    /*
     * save or update the model
     *
     * @param { string } query
     *
     * @return { Promise }
     * */
    saveOrUpdate(query) {
        return __awaiter(this, void 0, void 0, function* () {
            let resp;
            switch (this.dbEngine) {
                case 'mysql':
                    resp = this.mysqlQuery(query);
                    break;
                case 'postgres':
                    resp = this.postgresQuery(query);
                    break;
                default:
                    resp = this.mysqlQuery(query);
            }
            return resp;
        });
    }
    /*
     * free statement to the database
     *
     * @param { string } query
     *
     * @return { Promise }
     * */
    freeStatement(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.statementSelector(query);
        });
    }
    /*
     * execute and generate the model/collection instance
     *
     * @param { string } query
     * @param { Model/Model } model
     *
     * @return { Promise }
     * */
    statement(query, model) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let err, data;
                [err, data] = yield to_1.default(self.statementSelector(query));
                if (err || !data)
                    reject(err);
                let collection = self.generateCollectionIfNeeded(data, model);
                resolve(collection);
            }));
        });
    }
    /*
     * select the proper statement
     *
     * @param { string } query
     *
     * @return { Promise }
     * */
    statementSelector(query) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this.dbEngine) {
                case 'mysql':
                    return this.mysqlQuery(query);
                case 'postgres':
                    return this.postgresQuery(query);
                default:
                    return this.mysqlQuery(query);
            }
        });
    }
    /*
     * query to the postres database
     *
     * @param { string } queryString
     *
     * @return { Promise }
     * */
    postgresQuery(queryString) {
        const self = this;
        return new Promise(function (resolve, reject) {
            try {
                self.db.query(queryString, (err, res) => {
                    if (err) {
                        console.error("selector.ts -> postgresQuery: ", err);
                        reject(err);
                        return;
                    }
                    if (res.hasOwnProperty('rows'))
                        resolve(res.rows);
                    else
                        resolve(res);
                    //self.db.end()
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    /*
     * query to the mysql database
     *
     * @param { string } queryString
     *
     * @return { Promise }
     * */
    mysqlQuery(queryString) {
        let self = this;
        return new Promise(function (resolve, reject) {
            try {
                self.db.query(queryString, function (err, rows, fields) {
                    if (err) {
                        console.error("selector.ts -> mysqlQuery: ", err);
                        reject(err);
                    }
                    resolve(rows);
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    /*
     * generate a collection if it is needed
     *
     * @param { array } data
     * @param { models/model } model
     *
     * @return { Promise }
     * */
    generateCollectionIfNeeded(data, model) {
        if (!data)
            return;
        if (data.length > 1) {
            return new CollectionService_1.default(data, model);
        }
        return model.create(data[0]);
    }
}
exports.default = selector;
//# sourceMappingURL=selector.js.map