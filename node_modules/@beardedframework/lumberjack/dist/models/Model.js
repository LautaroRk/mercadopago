"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const db_1 = require("../database/db");
const Objects_1 = require("../helpers/Objects");
const queryBuilder_1 = require("../database/queryBuilder");
const DatetimeService_1 = require("../services/DatetimeService");
class Model extends queryBuilder_1.default {
    //public static table : string = '';
    /*
     *
     * class construtor
     *
     * */
    constructor(data = {}) {
        super();
        /*
         * @var { string } the table name
         * */
        this.table = '';
        /*
         * @var { array } the fillable fields
         * */
        this.fillable = [];
        /*
         * @var { array } the hidden fields
         * */
        this.hidden = [];
        /*
         * @var { array } the fields of the table
         * */
        this.fields = [];
        /*
         * @var { array } the fields to be parsed as date
         * */
        this.DatetimeValues = ['created_at', 'updated_at', 'deleted_at', 'last_login'];
        this.data = data;
        //this.columns()
    }
    /*
     * Save a model instance on database
     *
     * @return { Promise }
     *
     * */
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.data.hasOwnProperty('id')) {
                return db_1.default.Instance.update(this);
            }
            else {
                //Logger.info( 'should fill need hide fields');    
                //this.fillHiddenValuesEmptyOnNewElement();
                return db_1.default.Instance.save(this);
            }
        });
    }
    /*
     * parse the model to json
     *
     * @return { object }
     *
     * */
    toJson() {
        let self = this;
        let resp = Objects_1.default.map(this.data, function (value, key) {
            if (!Objects_1.default.inArray(self.hidden, key)) {
                if (self.DatetimeValues.indexOf(key) > -1)
                    return DatetimeService_1.default.formatter(value);
                return value;
            }
        });
        return resp;
    }
    /*
     * parse to array
     *
     * @return { Array }
     *
     * */
    toArray() {
        let resp = Objects_1.default.mapToArray(this.data, function (value, key) {
            //console.log(key);
            return value;
        });
        return resp;
    }
    /*
     * has many
     *
     * @return { Model/Model } otherModel
     * @return { string } otherIndex
     * @return { string } myIndex
     *
     * @return { Promise }
     *
     * */
    hasManyToMany(otherModel, pivotTable, otherPivot, myPivot, otherIndex = 'id', myIndex = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            //let builder = new queryBuilder(pivotTable)
            let otherInstance = new otherModel();
            let data = yield otherModel.select(`${otherInstance.table}.*`)
                .where(`${pivotTable}.${myPivot}`, '=', `${this.data[myIndex]}`)
                .join(`${pivotTable}`, `${pivotTable}.${otherPivot}`, '=', `${otherInstance.table}.${otherIndex}`)
                .get();
            this.data[`${otherInstance.constructor.name.toLowerCase()}`] = data.toJson();
            return data;
        });
    }
    /*
     * has many
     *
     * @return { Model/Model } otherModel
     * @return { string } otherIndex
     * @return { string } myIndex
     *
     * @return { Promise }
     *
     * */
    hasMany(otherModel, otherIndex, myIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let instance = new otherModel();
            let data = yield otherModel.select('*')
                .where(`${instance.table}.${otherIndex}`, '=', `${this.data[myIndex]}`)
                .get();
            //this.data.${name} = data.toArray();
            this.data[`${instance.constructor.name.toLowerCase()}`] = data.toJson();
            return data;
        });
    }
    /*
     * get belongs to many
     *
     * @return { Model/Model } otherModel
     * @return { string } otherIndex
     * @return { string } myIndex
     *
     * @return { Promise }
     *
     * */
    belongsToMany(otherModel, otherIndex, myIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let instance = new otherModel();
            let data = yield otherModel.select('*')
                .where(`${instance.table}.${otherIndex}`, '=', `${this.data.id}`)
                .get();
            //this.data.${name} = data.toArray();
            this.data[`${instance.constructor.name.toLowerCase()}`] = data.toJson();
            return data;
        });
    }
    /*
     * get the one relation
     *
     * @return { Model/Model } otherModel
     * @return { string } otherIndex
     * @return { string } myIndex
     *
     * @return { Promise }
     *
     * */
    belongsTo(otherModel, otherIndex, myIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let instance = new otherModel();
            let data = yield otherModel.select('*')
                .where(`${instance.table}.${otherIndex}`, '=', `${this.data.id}`)
                .first();
            //this.data.${name} = data.toArray();
            this.data[`${instance.constructor.name.toLowerCase()}`] = data.toJson();
            return data;
        });
    }
    /*
     * get the one relation
     *
     * @return { Model/Model } otherModel
     * @return { string } otherIndex
     * @return { string } myIndex
     *
     * @return { Promise }
     *
     * */
    hasOne(otherModel, otherIndex, myIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let instance = new otherModel();
            let data = yield otherModel.select('*')
                .where(`${instance.table}.${otherIndex}`, '=', `${this.data[myIndex]}`)
                .first();
            //this.data.${name} = data.toArray();
            this.data[`${instance.constructor.name.toLowerCase()}`] = data.toJson();
            return data;
        });
    }
    /*
     * create a new instance of the model
     *
     * @param { any } data
     *
     * @return { Model/Model }
     *
     * */
    static create(data) {
        return new this(data);
    }
    /*
     * find a new instance of the model
     *
     * @param { number } id
     *
     * @return { promise }
     *
     * */
    static find(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return Model.findRow(id, this);
            // return await db.Instance.find (id, this);
        });
    }
    /*
     * fetch the collection of models
     *
     *
     * @return { promise }
     *
     * */
    static fetchPaginated(page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            return Model.fetchAllpaginated(this, page);
            //return db.Instance.fetchAll (this);
        });
    }
    /*
     * fetch the collection of models
     *
     *
     * @return { promise }
     *
     * */
    static fetchAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return Model.fetchAllrows(this);
            //return db.Instance.fetchAll (this);
        });
    }
    /*
     * start a queryBuilder instance with select
     *
     * @param { Array } args
     *
     * @return { queryBuilder }
     *
     * */
    static select(...args) {
        let qryBuilder = new queryBuilder_1.default();
        qryBuilder.setModel(this);
        return qryBuilder.select(args);
    }
    /*
     *
     * start a queryBuilder instance with where
     *
     * @param { String } field
     * @param { String } comparer
     * @param { any } value
     *
     * @return { queryBuilder }
     *
     * */
    static where(field, comparer, value) {
        let qryBuilder = new queryBuilder_1.default();
        qryBuilder.setModel(this);
        return qryBuilder.where(field, comparer, value);
    }
    /*
     * used to fill hidden values empty on new elements
     *
     * @return void
     *
     * */
    fillHiddenValuesEmptyOnNewElement() {
        for (let valueAsKey of this.hidden) {
            if (this.data.hasOwnProperty(valueAsKey))
                continue;
            let el = {};
            el[valueAsKey] = 'valueaskey';
            this.data = Object.assign(this.data, el);
        }
    }
    /*
     * get the columns of the table
     *
     *
     * @return { Promise }
     *
     * */
    columns() {
        return __awaiter(this, void 0, void 0, function* () {
            const cols = yield db_1.default.Instance.columns(this);
            this.fields = cols;
        });
    }
}
exports.default = Model;
//# sourceMappingURL=Model.js.map